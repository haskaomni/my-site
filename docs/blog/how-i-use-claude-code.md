---
title: 我如何使用 Claude Code
description: 一套以"先规划再执行"为核心的 Claude Code 工作流，通过研究、计划、标注循环和实现四个阶段，大幅提升 AI 编程质量。
---

# 我如何使用 Claude Code

> 原文：[How I Use Claude Code](https://boristane.com/blog/how-i-use-claude-code/) · 作者：Boris Tane

我用 [Claude Code](https://docs.anthropic.com/en/docs/claude-code) 作为主力开发工具大概已经 9 个月了，我最终形成的工作流和大多数人用 AI 编程工具的方式截然不同。大多数开发者就是输入提示词，偶尔用一下 plan 模式，修修报错，然后重复。更"上网冲浪"一些的人会拼接各种循环、MCP、gas town（还记得那些吗？）之类的东西。两种方式的结果都是一团糟——稍微复杂一点的场景就完全崩溃。

我要介绍的工作流有一个核心原则：**在你审核并批准书面计划之前，永远不要让 Claude 写代码。** 将规划与执行分离，是我做的最重要的一件事。它能防止无效劳动，让我掌控架构决策，并且用最少的 token 产出比直接写代码好得多的结果。

```
研究 → 计划 → 标注（重复 1-6 次）→ 任务清单 → 实现 → 反馈与迭代
```

## 第一阶段：研究

每个有意义的任务都从深度阅读指令开始。我让 Claude 在做任何事之前，先彻底理解代码库的相关部分。而且我**总是**要求把发现写入一个持久化的 markdown 文件——绝不只是聊天里的口头总结。

> 深度阅读这个文件夹，深入理解它的工作方式、功能和所有细节。完成后，在 research.md 中写一份详细的发现报告。

> 深入研究通知系统的细节，理解其中的复杂之处，然后写一份详细的 research.md 文档，包含关于通知工作方式的一切。

> 走查任务调度流程，深入理解并寻找潜在的 bug。系统确实存在 bug，因为它有时会运行本应被取消的任务。持续研究直到找到所有 bug，不要中途停止。完成后，在 research.md 中写一份详细的发现报告。

注意措辞："深入"、"深入研究"、"复杂之处"、"走查所有内容"。这不是废话。没有这些词，Claude 会浮于表面。它会读一个文件，看看函数签名层面在做什么，然后就跳过了。你需要明确表示表层阅读是不可接受的。

写出来的文档（research.md）至关重要。这不是为了让 Claude 做作业。它是我的**审查面**。我可以读它，验证 Claude 是否真的理解了系统，并在任何规划发生之前纠正误解。如果研究是错的，计划就是错的，实现也会是错的。垃圾进，垃圾出。

这是 AI 辅助编程中最昂贵的失败模式——不是语法错误或逻辑 bug，而是**在隔离环境中能跑但会破坏周围系统的实现**。一个忽略已有缓存层的函数、一个没考虑 ORM 约定的迁移、一个重复了别处已有逻辑的 API 端点。研究阶段可以预防所有这些问题。

## 第二阶段：规划

审核完研究后，我会要求在一个单独的 markdown 文件中写出详细的实现计划。

> 我想构建一个新功能 <名称和描述>，扩展系统以实现 <业务目标>。写一份详细的 plan.md 文档来说明如何实现。包含代码片段。

> 列表接口需要支持基于游标的分页而不是偏移量分页。写一份详细的 plan.md 来说明如何实现。在提出修改建议之前先阅读源文件，基于实际代码库来写计划。

生成的计划总是包含：方法的详细说明、展示实际修改的代码片段、要修改的文件路径，以及注意事项和权衡。

我用自己的 .md 计划文件，而不是 Claude Code 内置的 plan 模式。内置的 plan 模式很烂。我的 markdown 文件给了我完全的控制权。我可以在编辑器里编辑它、添加内联批注，而且它作为真正的文件留存在项目中。

我经常用的一个技巧：对于边界清晰的功能，如果我在某个开源仓库中见过不错的实现，我会把那段代码作为参考和计划请求一起给出。如果我想添加可排序的 ID，我就把某个做得不错的项目的 ID 生成代码贴过去，然后说"这是他们做可排序 ID 的方式，写一份 plan.md 说明我们如何采用类似的方案。"当 Claude 有具体的参考实现时，效果会比从零设计好得多。

但计划文档本身不是有趣的部分。有趣的是接下来发生的事。

## 标注循环

这是我工作流中最有特色的部分，也是我贡献最大价值的地方。

```
Claude 写 plan.md → 我在编辑器中审查 → 我添加内联批注 → 把 Claude 送回文档 → Claude 更新计划 → 满意？→ 不满意则重复 → 满意则请求任务清单
```

Claude 写完计划后，我在编辑器中打开它，直接在文档中添加内联批注。这些批注用来纠正假设、否决方案、添加约束，或者提供 Claude 不具备的领域知识。

批注长短不一。有时只有两个字："不可选"——写在 Claude 标记为可选的参数旁边。有时则是一段话，解释某个业务约束或粘贴一段代码展示我期望的数据结构。

一些真实的批注示例：

- "用 drizzle:generate 做迁移，不要裸写 SQL"——Claude 不知道的领域知识
- "不——这应该是 PATCH，不是 PUT"——纠正错误假设
- "整个删掉，我们这里不需要缓存"——否决提议的方案
- "队列消费者已经处理了重试，所以这段重试逻辑是多余的。删掉它，让它直接失败就好"——解释为什么要改
- "这是错的，visibility 字段应该在列表本身上，不是在单个条目上。当列表是公开的，所有条目都是公开的。据此重构 schema 部分"——重新调整计划的整个章节

然后我把 Claude 送回文档：

> 我在文档里加了一些批注，处理所有批注并相应更新文档。先不要实现。

这个循环重复 1 到 6 次。显式的"先不要实现"守卫至关重要。没有它，Claude 一觉得计划差不多了就会跳去写代码。在我说可以之前，它还不够好。

### 为什么这样做效果这么好

markdown 文件充当我和 Claude 之间的**共享可变状态**。我可以按自己的节奏思考，精确标注哪里有问题，然后重新开始而不丢失上下文。我不需要试图在聊天消息里解释所有东西。我是指着文档中确切的位置，把我的修正写在那里。

这和试图通过聊天消息来引导实现有根本区别。计划是一个结构化的、完整的规格说明，我可以整体审查。聊天对话则需要我回滚翻阅来重建决策过程。计划每次都赢。

三轮"我加了批注，更新计划"就能把一个通用的实现计划变成一个完美契合现有系统的方案。Claude 非常擅长理解代码、提出解决方案和编写实现。但它不了解我的产品优先级、用户痛点，以及我愿意做的工程权衡。标注循环就是我注入这些判断的方式。

### 任务清单

在实现开始前，我总是要求一个细粒度的任务分解：

> 在计划中添加一个详细的任务清单，包含完成计划所需的所有阶段和单个任务——先不要实现。

这会创建一个检查清单，在实现过程中用作进度追踪器。Claude 在完成时逐项标记，这样我随时都能看一眼计划，清楚知道进展到哪了。在持续数小时的会话中尤其有用。

## 第三阶段：实现

计划就绪后，我发出实现指令。我已经把它提炼成一个跨会话复用的标准提示词：

> 全部实现。完成一个任务或阶段后，在计划文档中标记为已完成。在所有任务和阶段完成之前不要停止。不要添加不必要的注释或 jsdoc，不要使用 any 或 unknown 类型。持续运行 typecheck 确保没有引入新问题。

这条提示词编码了所有重要的东西：

- **"全部实现"**：执行计划中的所有内容，不要挑拣
- **"在计划文档中标记为已完成"**：计划是进度的唯一真实来源
- **"在所有任务和阶段完成之前不要停止"**：中途不要暂停请求确认
- **"不要添加不必要的注释或 jsdoc"**：保持代码干净
- **"不要使用 any 或 unknown 类型"**：保持严格类型
- **"持续运行 typecheck"**：早发现问题，而不是最后

我在几乎每个实现会话中都使用这个精确措辞（有细微变化）。当我说"全部实现"的时候，每个决策都已经做出并验证了。实现变成了机械性的，而不是创造性的。这是故意的。我希望实现是无聊的。创造性工作发生在标注循环中。一旦计划正确，执行应该是简单直接的。

没有规划阶段，典型的情况是 Claude 在早期做了一个合理但错误的假设，在此基础上建设 15 分钟，然后我不得不撤销一连串改动。"先不要实现"守卫完全消除了这个问题。

## 实现过程中的反馈

一旦 Claude 在执行计划，我的角色从架构师转变为监督者。我的提示词变得极为简短。

```
Claude 实现 → 我审查/测试 → 正确？→ 不正确则简短纠正 → 正确则继续下一个任务 → 全部完成
```

规划批注可能是一整段话，但实现纠正通常只需一句话：

- "你没有实现 deduplicateByTitle 函数。"
- "你把设置页面建在了主应用中，它应该在管理应用里，移过去。"

Claude 有计划的完整上下文和正在进行的会话，所以简短的纠正就够了。

前端工作是最需要迭代的部分。我在浏览器里测试，然后快速发出纠正：

- "更宽"
- "还是被裁切了"
- "有 2px 的间隙"

对于视觉问题，我有时会附截图。一张表格没对齐的截图比文字描述能更快地传达问题。

我还经常引用已有代码：

- "这个表格应该和用户表看起来一模一样，相同的表头、相同的分页、相同的行密度。"

这比从零描述一个设计要精确得多。成熟代码库中的大多数功能都是现有模式的变体。新的设置页面应该看起来和现有的设置页面一样。指向参考就传达了所有隐含需求，不需要逐一说明。Claude 通常会在做纠正之前先读参考文件。

当某些东西走偏了，我不会试图打补丁。我会通过丢弃 git 变更来回退并重新界定范围：

- "我回退了所有内容。现在我只想让列表视图更简洁——其他什么都不做。"

回退后收窄范围，几乎总是比试图逐步修复一个糟糕的方案产出更好的结果。

## 保持主导

尽管我把执行委托给了 Claude，但我从不给它对构建内容的完全自主权。我把绝大部分主动引导工作放在 plan.md 文档中。

这很重要，因为 Claude 有时会提出技术上正确但对项目来说不对的方案。也许方案过度工程化了，或者它改了一个其他系统部分依赖的公共 API 签名，又或者它在有更简单选项的情况下选了更复杂的。我对更广泛的系统、产品方向和工程文化有 Claude 不具备的上下文。

**从提案中挑选**：当 Claude 识别出多个问题时，我会逐一处理："第一个，直接用 Promise.all，别搞那么复杂；第三个，提取到一个独立函数提高可读性；第四和第五个忽略，不值得增加复杂度。"我在根据对当前重要性的判断做逐项决策。

**削减范围**：当计划包含锦上添花的内容时，我会主动砍掉。"把下载功能从计划中删掉，我现在不想实现这个。"这能防止范围蔓延。

**保护已有接口**：当我知道某些东西不该改时，我会设置硬约束："这三个函数的签名不能变，调用方应该适配，而不是库。"

**覆盖技术选择**：有时我有 Claude 不知道的特定偏好："用这个模型而不是那个"或者"用这个库的内置方法而不是自己写一个。"快速、直接的覆盖。

Claude 处理机械性执行，而我做判断性决策。计划预先捕获了重大决策，选择性引导处理实现过程中出现的小决策。

## 单个长会话

我在单个长会话中运行研究、规划和实现，而不是拆分到多个会话中。一个会话可能从深度阅读一个文件夹开始，经过三轮计划标注，然后运行完整实现——全部在一个连续对话中。

我**没有**看到大家说的上下文窗口超过 50% 后性能下降的问题。实际上，当我说"全部实现"的时候，Claude 已经在整个会话中积累了理解：研究阶段读文件、标注循环中优化心智模型、吸收我的领域知识纠正。

当上下文窗口填满时，Claude 的自动压缩维持了足够的上下文来继续工作。而且计划文档——那个持久化的文件——以完整保真度存活于压缩中。我可以随时让 Claude 回去看它。

## 一句话总结

深度阅读，写计划，标注计划直到它正确，然后让 Claude 不停歇地执行全部内容，期间持续检查类型。

就这样。没有魔法提示词，没有精心设计的系统指令，没有聪明的技巧。只是一条纪律严明的流水线，把**思考**和**打字**分开。研究防止 Claude 做出无知的改动。计划防止它做出错误的改动。标注循环注入我的判断。实现指令让它在所有决策做完后不间断地运行。

试试我的工作流，你会疑惑自己以前没有标注计划文档的时候是怎么用编程 agent 交付任何东西的。
